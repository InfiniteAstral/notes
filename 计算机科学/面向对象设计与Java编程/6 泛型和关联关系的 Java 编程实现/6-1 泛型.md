# 6.1 泛型

::: tip
本页除目录以外的内容由 Gemini 2.5 Pro 生成，由 [TouHikari](https://github.com/TouHikari/) 审阅并修改。
:::

## 6.1.1 泛型简介

想象一下，你正在编写一个可以存放任何类型物品的储物箱。在没有泛型的情况下，你可能会用一个 `Object` 类型的箱子来存放所有物品。但这样做会带来一个问题：当你从箱子里取出物品时，你只知道它是一个 `Object`，却不知道它的具体类型是什么。为了安全地使用它，你必须进行强制类型转换，这不仅繁琐，而且容易出错。

Java 泛型（Generics）就是为了解决这类问题而生的。它允许我们在定义类、接口和方法时使用**类型参数**（Type Parameters），这些类型参数在使用时才被替换为具体的类型。通过这种方式，我们可以编写出更通用、更安全、更清晰的代码。

泛型的核心思想是**参数化类型**，即把类型像参数一样传递。

## 6.1.2 为什么使用泛型

对于初学者来说，理解泛型的必要性是掌握它的第一步。使用泛型主要有以下三个好处：

1.  **更强的类型检查**：Java 编译器可以对泛型代码进行更严格的类型检查。如果代码违反了类型安全，编译器会在编译时就发出错误，而不是在运行时才抛出 `ClassCastException`。这使得我们能更早地发现并修复错误。

2.  **消除强制类型转换**：泛型使得代码更加简洁易读。由于编译器已经知道了具体的类型，因此不再需要进行手动的强制类型转换。

3.  **代码重用性**：通过编写泛型算法，我们可以实现一个算法，然后用不同的类型进行实例化，从而轻松地重用它。例如，一个泛型的排序算法可以用于排序整数列表、字符串列表或任何其他可比较类型的列表。

让我们通过一个简单的例子来直观感受一下。

**不使用泛型：**

```java
import java.util.ArrayList;
import java.util.List;

public class NoGenericExample {
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add("Hello");
        list.add(123); // 编译时不会报错

        for (Object obj : list) {
            // 需要强制类型转换，且容易出错
            try {
                String str = (String) obj;
                System.out.println(str.length());
            } catch (ClassCastException e) {
                System.err.println("类型转换错误: " + e.getMessage());
            }
        }
    }
}
```

在上面的代码中，`ArrayList` 可以存放任何类型的对象。当我们尝试将一个整数 `123` 转换为字符串时，就会在运行时抛出 `ClassCastException`。

**使用泛型：**

```java
import java.util.ArrayList;
import java.util.List;

public class GenericExample {
    public static void main(String[] args) {
        // 创建时指定类型为 String
        List<String> list = new ArrayList<>();
        list.add("Hello");
        // list.add(123); // 编译时就会报错！

        for (String str : list) {
            // 无需强制类型转换
            System.out.println(str.length());
        }
    }
}
```

在这个版本中，我们明确指定了 `List` 只能存放 `String` 类型的对象。当我们试图添加一个整数时，编译器会立即报错，从而避免了在运行时出现类型转换错误。代码也变得更加清晰和安全。

## 6.1.3 泛型类

泛型类是在实例化时接受类型参数的类。这是泛型最常见的用法之一。

### 定义泛型类

定义一个泛型类非常简单，只需在类名后面加上用尖括号 `<>` 包围的类型参数即可。按照惯例，类型参数通常使用单个大写字母来表示，例如 `T` (Type), `E` (Element), `K` (Key), `V` (Value) 等。

下面是一个简单的泛型类 `Box` 的例子，它可以用来存放任何类型的物品：

```java
public class Box<T> {
    // T 代表 "Type"
    private T t;

    public void set(T t) {
        this.t = t;
    }

    public T get() {
        return t;
    }

    public static void main(String[] args) {
        // 创建一个存放 Integer 的 Box
        Box<Integer> integerBox = new Box<>();
        integerBox.set(10);
        Integer someInteger = integerBox.get();
        System.out.println(someInteger); // 输出 10

        // 创建一个存放 String 的 Box
        Box<String> stringBox = new Box<>();
        stringBox.set("Hello World");
        String someString = stringBox.get();
        System.out.println(someString); // 输出 Hello World
    }
}
```

在这个例子中：

- `Box<T>` 定义了一个泛型类，`T` 是一个类型参数。
- `private T t;` 声明了一个类型为 `T` 的成员变量。
- `public void set(T t)` 和 `public T get()` 方法都使用了类型参数 `T`。
- 在 `main` 方法中，我们通过 `Box<Integer>` 和 `Box<String>` 创建了 `Box` 类的两个实例，分别指定 `T` 为 `Integer` 和 `String`。这个过程称为**泛型实例化**。

### 多个类型参数

泛型类也可以有多个类型参数。例如，我们可以创建一个 `Pair` 类，用于存放一对值：

```java
public class Pair<K, V> {
    private K key;
    private V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public K getKey() {
        return key;
    }

    public V getValue() {
        return value;
    }

    public static void main(String[] args) {
        Pair<String, Integer> pair = new Pair<>("Age", 25);
        String key = pair.getKey();
        Integer value = pair.getValue();
        System.out.println(key + ": " + value); // 输出 Age: 25
    }
}
```

## 6.1.4 泛型方法

除了泛型类，我们还可以定义**泛型方法**。泛型方法是在调用时接受类型参数的方法，它可以定义在普通类中，也可以定义在泛型类中。

### 定义泛型方法

泛型方法的类型参数列表位于修饰符（如 `public static`）和返回类型之间。

```java
public class GenericMethodExample {

    // 这是一个泛型方法
    public static <E> void printArray(E[] inputArray) {
        // 遍历并打印数组元素
        for (E element : inputArray) {
            System.out.printf("%s ", element);
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // 创建不同类型的数组
        Integer[] intArray = { 1, 2, 3, 4, 5 };
        Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 };
        Character[] charArray = { 'H', 'E', 'L', 'L', 'O' };

        System.out.println("整型数组元素为:");
        printArray(intArray); // 传递 Integer 数组

        System.out.println("\n双精度浮点型数组元素为:");
        printArray(doubleArray); // 传递 Double 数组

        System.out.println("\n字符型数组元素为:");
        printArray(charArray); // 传递 Character 数组
    }
}
```

在这个例子中，`printArray` 方法就是一个泛型方法。它的类型参数是 `<E>`。这个方法接受一个类型为 `E[]` 的数组，并可以处理任何类型的数组，如 `Integer[]`, `Double[]`, `Character[]` 等。

注意，泛型方法中的类型参数 `E` 的作用域仅限于该方法本身。

## 6.1.5 有界类型参数

有时候，我们可能希望限制泛型参数的类型范围。例如，一个用于比较大小的方法，我们希望它的参数类型必须实现了 `Comparable` 接口。这时就可以使用**有界类型参数**（Bounded Type Parameters）。

有界类型参数通过 `extends` 关键字来指定上界。注意，无论是类还是接口，都使用 `extends`。

```java
public class BoundedTypeParameterExample {

    // T 必须是 Number 的子类（或 Number 本身）
    // 并且 T 必须实现 Comparable<T> 接口
    public static <T extends Number & Comparable<T>> T findMax(T[] array) {
        if (array == null || array.length == 0) {
            return null;
        }

        T max = array[0];
        for (int i = 1; i < array.length; i++) {
            if (array[i].compareTo(max) > 0) {
                max = array[i];
            }
        }
        return max;
    }

    public static void main(String[] args) {
        Integer[] intArray = { 1, 5, 2, 8, 3 };
        System.out.println("最大值是: " + findMax(intArray)); // 输出 8

        Double[] doubleArray = { 1.1, 5.5, 2.2, 8.8, 3.3 };
        System.out.println("最大值是: " + findMax(doubleArray)); // 输出 8.8

        // String[] strArray = { "a", "b", "c" };
        // findMax(strArray); // 编译错误！String 不是 Number 的子类
    }
}
```

在 `findMax` 方法中，类型参数 `T` 有一个上界：`Number & Comparable<T>`。这意味着传递给 `findMax` 方法的类型必须同时是 `Number` 的子类并实现了 `Comparable` 接口。这保证了我们可以安全地调用 `compareTo` 方法。

## 6.1.6 通配符

通配符（Wildcards）是泛型中一个强大但又有些复杂的概念。它用问号 `?` 表示，代表未知的类型。通配符主要用于灵活地引用泛型类型，尤其是在方法参数中。

通配符有三种形式：

1.  **上界通配符 (Upper Bounded Wildcards): `? extends Type`**

    - 表示参数类型是 `Type` 或 `Type` 的某个子类。
    - 这种集合是**只读**的，你不能向其中添加任何对象（除了 `null`），因为编译器无法确定 `?` 到底代表哪个具体的子类型。

2.  **下界通配符 (Lower Bounded Wildcards): `? super Type`**

    - 表示参数类型是 `Type` 或 `Type` 的某个父类。
    - 这种集合是**可写**的，你可以向其中添加 `Type` 或其子类型的对象。但是，当你从中读取数据时，只能得到 `Object` 类型的对象。

3.  **无界通配符 (Unbounded Wildcards): `?`**
    - 表示参数类型是未知的，可以是任何类型。
    - 与 `? extends Object` 等价。
    - 同样是只读的。

### PECS 原则

一个方便记忆的法则是 **PECS**：**P**roducer **E**xtends, **C**onsumer **S**uper。

- **Producer Extends**：如果你的泛型集合主要用于**生产**（提供）数据（即你从中读取数据），那么使用 `? extends T`。
- **Consumer Super**：如果你的泛型集合主要用于**消费**（接收）数据（即你向其中写入数据），那么使用 `? super T`。

**示例：**

```java
import java.util.ArrayList;
import java.util.List;

public class WildcardExample {

    // 上界通配符：可以处理 Number 及其子类的列表
    public static double sumOfList(List<? extends Number> list) {
        double sum = 0.0;
        for (Number n : list) {
            sum += n.doubleValue();
        }
        // list.add(123); // 编译错误！不能添加元素
        return sum;
    }

    // 下界通配符：可以将 Integer 或其子类对象添加到列表中
    public static void addIntegers(List<? super Integer> list) {
        list.add(1);
        list.add(2);
        // Number n = list.get(0); // 编译错误！只能得到 Object
    }

    public static void main(String[] args) {
        List<Integer> intList = new ArrayList<>();
        intList.add(10);
        intList.add(20);
        System.out.println("Sum = " + sumOfList(intList)); // 输出 30.0

        List<Double> doubleList = new ArrayList<>();
        doubleList.add(10.5);
        doubleList.add(20.5);
        System.out.println("Sum = " + sumOfList(doubleList)); // 输出 31.0

        List<Number> numList = new ArrayList<>();
        addIntegers(numList);
        System.out.println(numList); // 输出 [1, 2]
    }
}
```

## 6.1.7 类型擦除

Java 的泛型是通过**类型擦除**（Type Erasure）来实现的。这意味着在编译后，所有泛型类型信息都会被擦除掉。

具体来说，编译器会做以下事情：

1.  将所有泛型参数替换为它们的边界（如果是有界类型参数）或 `Object`（如果是无界类型参数）。例如，`T` 会被替换为 `Object`，`T extends Number` 会被替换为 `Number`。
2.  在需要的地方插入强制类型转换，以保持类型安全。
3.  生成桥接方法（Bridge Methods）以在继承泛型类型时保持多态性。

由于类型擦除，以下代码在编译后实际上是相同的：

```java
List<String> stringList = new ArrayList<>();
List<Integer> integerList = new ArrayList<>();

// 编译后都变成了
List stringList = new ArrayList();
List integerList = new ArrayList();
```

这就是为什么你不能这样做：

```java
// public void print(List<String> list) {}
// public void print(List<Integer> list) {} // 编译错误！方法签名冲突
```

因为在擦除类型后，两个方法的签名都变成了 `print(List list)`。

理解类型擦除有助于解释泛型的一些行为和限制，例如：

- 不能创建泛型类型的实例：`new T()` 是不允许的。
- 不能创建泛型数组：`new T[5]` 是不允许的。
- `instanceof` 不能用于泛型参数：`if (obj instanceof T)` 是不允许的。

## 6.1.8 总结

泛型是 Java 语言中一个非常重要的特性，它极大地增强了代码的健壮性、可读性和重用性。通过参数化类型，我们可以在编译时捕获更多的错误，避免运行时的类型转换异常，并编写出更加通用和灵活的代码。

对于初学者来说，掌握泛型的关键在于理解其核心思想和带来的好处。从泛型类和泛型方法开始，逐步学习有界类型参数和通配符，最后了解类型擦除的实现原理，你就能在实际开发中自如地运用泛型了。
