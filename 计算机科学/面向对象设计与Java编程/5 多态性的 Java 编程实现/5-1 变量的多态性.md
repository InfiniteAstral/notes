# 5.1 变量的多态性

::: tip
本页内容由 Gemini 2.5 Pro 生成，由 [TouHikari](https://github.com/TouHikari/) 审阅并修改。
:::

在面向对象编程中，多态性（Polymorphism）是一个非常核心和强大的概念。它与封装和继承一起，构成了面向对象编程的三大支柱。多态性允许我们以一种统一的方式来处理不同类型的对象，从而使代码更加灵活、可扩展和可维护。

## 什么是多态性？

从字面上看，“多态”意味着“多种形态”。在编程中，多态性指的是**相同类型的变量，在引用不同类型的对象时，会表现出不同的行为**。

更具体地说，在 Java 中，多态性允许一个父类（或接口）的引用变量指向其任何一个子类的对象。当通过这个父类引用调用一个被子类重写（Override）的方法时，实际执行的是子类中的方法版本。这种在运行时才确定调用哪个方法的现象，被称为**动态绑定**（Dynamic Binding）。

要实现多态性，需要满足以下几个前提条件：
1.  **继承关系**：必须存在类之间的继承关系。
2.  **方法重写**：子类必须重写父类的方法。
3.  **父类引用指向子类对象**：通过父类的引用变量来引用子类的对象。

## 变量的多态性：编译时类型 vs 运行时类型

变量的多态性是多态性最直观的体现。它指的是一个引用变量的“编译时类型”和“运行时类型”可以不一致。

*   **编译时类型**：由声明该变量时使用的类型决定。编译器在编译阶段会根据这个类型来检查语法和方法调用是否正确。
*   **运行时类型**：由实际赋给该变量的对象类型决定。程序在运行时，JVM 会根据这个类型来确定到底执行哪个类的方法。

例如，我们有一个 `Animal` 父类和两个子类 `Dog` 和 `Cat`。

```java
// 声明一个 Animal 类型的变量
Animal myAnimal;
```

在这里，`myAnimal` 变量的**编译时类型**是 `Animal`。

现在，我们可以让这个变量引用一个 `Dog` 对象：

```java
myAnimal = new Dog(); // 运行时类型是 Dog
```

也可以让它引用一个 `Cat` 对象：

```java
myAnimal = new Cat(); // 运行时类型是 Cat
```

这就是变量的多态性：`myAnimal` 这个变量可以引用 `Dog` 类型的对象，也可以引用 `Cat` 类型的对象，它具有了“多种形态”的能力。

当我们通过 `myAnimal` 调用一个方法时（例如 `makeSound()`），编译器只会检查 `Animal` 类（编译时类型）中是否存在这个方法。如果存在，代码就能通过编译。而在程序运行时，Java 虚拟机会根据 `myAnimal` 变量实际引用的对象类型（运行时类型），来决定到底执行 `Dog` 类的 `makeSound()` 方法还是 `Cat` 类的 `makeSound()` 方法。

## 代码示例

为了更好地理解变量的多态性，让我们来看一个完整的 Java 代码示例。

首先，我们定义一个 `Animal` 类，它有一个 `makeSound()` 方法：

```java
// Animal.java
public class Animal {
    public void makeSound() {
        System.out.println("动物发出声音");
    }
}
```

接下来，我们创建两个 `Animal` 的子类：`Dog` 和 `Cat`。这两个子类都重写了父类的 `makeSound()` 方法：

```java
// Dog.java
public class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("小狗汪汪叫");
    }

    public void fetch() {
        System.out.println("小狗跑去捡球");
    }
}
```

```java
// Cat.java
public class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("小猫喵喵叫");
    }

    public void scratch() {
        System.out.println("小猫在抓沙发");
    }
}
```

最后，我们创建一个 `Main` 类来演示多态性：

```java
// Main.java
public class Main {
    public static void main(String[] args) {
        // 声明一个 Animal 类型的引用变量
        Animal myAnimal;

        // 1. 父类引用指向子类对象 (Dog)
        myAnimal = new Dog();
        System.out.println("变量引用的对象类型: " + myAnimal.getClass().getName());
        myAnimal.makeSound(); // 调用的是 Dog 类的方法

        System.out.println("--------------------");

        // 2. 父类引用指向子类对象 (Cat)
        myAnimal = new Cat();
        System.out.println("变量引用的对象类型: " + myAnimal.getClass().getName());
        myAnimal.makeSound(); // 调用的是 Cat 类的方法
    }
}
```

## 示例分析

上面的 `Main` 类中的代码清晰地展示了变量的多态性。让我们来逐步分析：

1.  **`Animal myAnimal;`**
    *   这行代码声明了一个名为 `myAnimal` 的引用变量。
    *   它的**编译时类型**是 `Animal`。这意味着在编译代码的时候，编译器会认为 `myAnimal` 就是一个 `Animal` 类型的变量，并据此检查语法的正确性（例如，`myAnimal` 只能调用 `Animal` 类中定义的方法）。

2.  **`myAnimal = new Dog();`**
    *   这行代码创建了一个 `Dog` 类的实例（对象），并将其内存地址赋值给 `myAnimal` 变量。
    *   此时，`myAnimal` 变量的**运行时类型**就变成了 `Dog`。
    *   虽然 `myAnimal` 在编译时被看作 `Animal`，但在运行时它实际指向的是一个 `Dog` 对象。

3.  **`myAnimal.makeSound();`**
    *   这是多态性的关键所在。当这行代码执行时：
        *   编译器在编译时检查 `Animal` 类（编译时类型）中是否有 `makeSound()` 方法。因为 `Animal` 类确实有这个方法，所以编译通过。
        *   在程序运行时，JVM（Java 虚拟机）会检查 `myAnimal` 变量当前引用的实际对象是什么类型。它发现 `myAnimal` 指向的是一个 `Dog` 对象。
        *   因此，JVM 会调用 `Dog` 类中重写的 `makeSound()` 方法，而不是 `Animal` 类中的版本。
    *   所以，程序会输出 “小狗汪汪叫”。

4.  **`myAnimal = new Cat();`**
    *   这里，我们将一个新的 `Cat` 对象赋值给了同一个 `myAnimal` 变量。
    *   `myAnimal` 变量的编译时类型仍然是 `Animal`，但它的**运行时类型**现在变成了 `Cat`。

5.  **`myAnimal.makeSound();` (第二次调用)**
    *   与第一次调用类似，JVM 检查到 `myAnimal` 此时指向的是一个 `Cat` 对象。
    *   因此，这次会调用 `Cat` 类中重写的 `makeSound()` 方法。
    *   程序会输出 “小猫喵喵叫”。

### 运行结果

将以上所有 Java 文件（`Animal.java`, `Dog.java`, `Cat.java`, `Main.java`）放在同一个目录下并编译运行 `Main.java`，你将得到以下输出：

```text
变量引用的对象类型: Dog
小狗汪汪叫
--------------------
变量引用的对象类型: Cat
小猫喵喵叫
```

这个结果完美地证明了变量的多态性：同一个 `Animal` 类型的变量 `myAnimal`，在引用不同子类对象时，调用同一个 `makeSound()` 方法，却表现出了完全不同的行为。

## 变量多态性的优点

变量的多态性是实现代码灵活性和可扩展性的关键。它的主要优点包括：

1.  **提高代码的灵活性和可维护性**：
    *   我们可以编写面向父类（或接口）的通用代码，而无需为每一种子类编写专门的处理逻辑。当需要添加新的子类时（例如，增加一个 `Bird` 类），现有的代码几乎不需要修改，只需确保新类继承自 `Animal` 并重写了必要的方法即可。这大大降低了代码的耦合度。

2.  **增强代码的可扩展性**：
    *   基于父类编写的方法可以轻松地接纳未来新增的任何子类对象。这使得系统在不修改现有代码库的情况下，就能方便地进行功能扩展，符合“开闭原则”（对扩展开放，对修改关闭）。

3.  **简化代码的编写**：
    *   我们可以将不同子类的对象统一放入一个父类类型的数组或集合中进行管理，然后遍历该集合，统一调用它们的方法，而无需判断每个对象的具体类型。这使得代码更加简洁和易于理解。

## 总结

变量的多态性是面向对象编程中的一个基石概念。它通过“一个接口，多种实现”的思想，让我们的代码摆脱了对具体类型的硬编码依赖，变得更加通用、灵活和易于扩展。理解并掌握变量的编译时类型和运行时类型之间的关系，以及方法调用的动态绑定机制，是成为一名优秀 Java 开发者的必经之路。