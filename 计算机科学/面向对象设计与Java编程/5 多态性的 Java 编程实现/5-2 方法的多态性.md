# 5.2 方法的多态性

在上一节中，我们学习了变量的多态性，即一个父类引用可以指向不同的子类对象。这种多态性是实现代码灵活性的基础。而方法的多态性，则是多态性在行为层面的直接体现，它让对象能够根据自身的实际类型来执行相应的方法，从而呈现出不同的行为。

方法的多态性主要通过两种技术来实现：**重写（Overriding）** 和 **重载（Overloading）**。这两种技术虽然名字相似，但它们在概念、规则和实现机制上有着本质的区别。

## 5.2.1 重写 vs. 重载

为了清晰地理解方法的多态性，我们必须首先能准确地区分重写和重载。

| 特性           | 重写 (Overriding)                                                                                                      | 重载 (Overloading)                                                                   |
| :------------- | :--------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------- |
| **定义**       | 子类重新定义了从父类继承来的、具有**相同方法签名**的方法。                                                             | 在**同一个类**中，定义了多个**同名**但**参数列表不同**的方法。                       |
| **目的**       | 改变或扩展父类方法的行为，以适应子类的特定需求。                                                                       | 提供多种方式来调用一个功能相似但处理的数据类型或数量不同的方法。                     |
| **范围**       | 发生在具有继承关系的**父类和子类**之间。                                                                               | 发生在**同一个类**中（也可以发生在父子类之间）。                                     |
| **方法签名**   | **必须完全相同**（方法名、参数列表）。                                                                                 | 方法名必须相同，但**参数列表必须不同**（参数的类型、数量或顺序至少有一项不同）。     |
| **返回类型**   | 可以与父类方法的返回类型相同，或者是其子类型。                                                                         | 与返回类型无关，可以相同也可以不同。                                                 |
| **访问修饰符** | 访问权限**不能比父类方法更严格**（例如，父类是 `protected`，子类可以是 `protected` 或 `public`，但不能是 `private`）。 | 与访问修饰符无关，可以任意定义。                                                     |
| **多态性类型** | **动态多态性**（运行时多态）。在运行时根据对象的实际类型来决定调用哪个方法。                                           | **静态多态性**（编译时多态）。在编译时根据调用方法时提供的参数来决定绑定到哪个方法。 |
| **绑定时机**   | **运行时绑定**（动态绑定）。                                                                                           | **编译时绑定**（静态绑定）。                                                         |

---

简单来说，它们的区别可以记为：

- **重写（Override）**：**外壳不变，核心重做**。发生在父子类之间，方法签名完全一样，但实现逻辑不同。
- **重载（Overload）**：**名字一样，参数多样**。发生在一个类中，方法名相同，但参数列表不同。

接下来，我们将分别详细探讨这两种实现方法多态性的方式。

## 5.2.2 方法的重写：动态多态性

方法的重写是实现动态多态性的核心机制。它允许子类根据自己的需求，重新实现从父类继承来的方法。当通过父类引用调用这个被重写的方法时，Java 虚拟机会在运行时进行动态绑定，选择执行子类中的方法版本。

### 重写的规则

要正确地重写一个方法，必须遵守以下规则，也就是我们常说的“两同两小一大”原则：

1.  **方法名相同**：子类方法的名称必须与父类方法的名称完全一致。
2.  **参数列表相同**：子类方法的参数类型、数量和顺序必须与父类方法的完全一致。
3.  **返回类型更小或相同**：子类方法的返回类型必须与父类方法的返回类型相同，或者是其子类。
4.  **抛出的异常更小或相同**：子类方法声明抛出的异常类必须是父类方法声明抛出异常类的子类或相同，或者不抛出任何异常。
5.  **访问权限更大或相同**：子类方法的访问修饰符必须具有比父类方法更大或相同的访问权限（`public` > `protected` > `default` > `private`）。

::: tip `@Override` 注解
这是一个非常有用的注解，推荐在所有重写的方法上都使用它。它的作用是告诉编译器，这个方法意图是重写父类的方法。如果因为拼写错误、参数列表不匹配等原因导致重写失败，编译器会立即报错，帮助我们及早发现问题。
:::

### 代码示例

让我们延用上一节的例子。`Dog` 和 `Cat` 类都重写了 `Animal` 类的 `makeSound()` 方法。

```java
// Animal.java
public class Animal {
    public void makeSound() {
        System.out.println("动物发出声音");
    }
}

// Dog.java
public class Dog extends Animal {
    @Override // 明确这是一个重写方法
    public void makeSound() {
        System.out.println("小狗汪汪叫");
    }
}

// Main.java
public class Main {
    public static void main(String[] args) {
        // 父类引用指向子类对象
        Animal myDog = new Dog();

        // 动态绑定：运行时 JVM 发现 myDog 的实际类型是 Dog，
        // 因此调用 Dog 类中重写的 makeSound() 方法。
        myDog.makeSound(); // 输出: 小狗汪汪叫
    }
}
```

在这个例子中，`myDog` 的编译时类型是 `Animal`，但运行时类型是 `Dog`。当调用 `makeSound()` 方法时，正是 `Dog` 类重写了这个方法，才实现了动态多态性，使得程序能够根据对象的真实身份（`Dog`）来执行相应的行为。

## 5.2.3 方法的重载：静态多态性

方法的重载是实现静态多态性的一种方式。它允许在一个类中定义多个同名的方法，只要它们的参数列表不同即可。编译器在编译代码时，会根据方法调用时提供的参数类型、数量和顺序，来决定具体绑定到哪一个方法，这个过程在编译阶段就已经完成，因此被称为静态绑定。

### 重载的规则

1.  **必须在同一个类中**（或者在父子类之间，子类可以重载父类的方法）。
2.  **方法名必须相同**。
3.  **参数列表必须不同**：
    - 参数的**数量**不同。
    - 参数的**类型**不同。
    - 参数的**顺序**不同（当参数类型不同时）。

::: warning 注意
方法的返回类型、访问修饰符或抛出的异常与重载无关。也就是说，仅仅是返回类型不同，是无法构成重载的。
:::

### 代码示例

让我们创建一个 `Calculator` 类来说明重载。这个类提供了一个 `add` 方法，但可以处理整数和浮点数的相加。

```java
// Calculator.java
public class Calculator {

    // 重载方法 1: 接受两个整数
    public int add(int a, int b) {
        System.out.println("调用 add(int, int)");
        return a + b;
    }

    // 重载方法 2: 接受两个双精度浮点数
    public double add(double a, double b) {
        System.out.println("调用 add(double, double)");
        return a + b;
    }

    // 重载方法 3: 接受三个整数
    public int add(int a, int b, int c) {
        System.out.println("调用 add(int, int, int)");
        return a + b + c;
    }
    // 这不是重载！仅仅返回类型不同是无效的。
    // public double add(int a, int b) {
    //     return (double)(a + b);
    // }
}

// Main.java
public class Main {
    public static void main(String[] args) {
        Calculator calculator = new Calculator();

        // 静态绑定：编译器根据参数 (1, 2) 决定调用 add(int, int)
        calculator.add(1, 2);

        // 静态绑定：编译器根据参数 (2.5, 3.5) 决定调用 add(double, double)
        calculator.add(2.5, 3.5);

        // 静态绑定：编译器根据参数 (1, 2, 3) 决定调用 add(int, int, int)
        calculator.add(1, 2, 3);
    }
}
```

### 运行结果

```text
调用 add(int, int)
调用 add(double, double)
调用 add(int, int, int)
```

从这个例子中可以看出，我们使用了同一个方法名 `add`，但是通过提供不同的参数，就可以调用到不同的方法实现。这为类的设计者提供了很大的便利，也让类的使用者能够更直观地调用方法，而无需去记忆多个不同的方法名（例如 `addInts`, `addDoubles` 等）。

## 5.2.4 方法多态性的实际应用

单独看变量的多态性和方法的多态性可能还不够直观。当我们将它们结合在一起时，多态的威力才能真正显现出来。这使得我们能够编写出高度通用和可扩展的代码。

想象一下，我们要编写一个程序来管理一个动物园。动物园里有各种各样的动物，我们希望有一个统一的方法来让所有动物发出叫声。

### 代码示例

我们将使用之前定义的 `Animal`, `Dog`, `Cat` 类，并增加一个 `Bird` 类。

```java
// Bird.java
public class Bird extends Animal {
    @Override
    public void makeSound() {
        System.out.println("小鸟啾啾叫");
    }
}

// Zoo.java
public class Zoo {
    public static void main(String[] args) {
        // 使用一个 Animal 类型的数组来统一管理所有动物
        // 这里就体现了变量的多态性
        Animal[] animals = new Animal[3];
        animals[0] = new Dog();
        animals[1] = new Cat();
        animals[2] = new Bird();

        // 遍历数组，让每只动物都发出声音
        for (Animal currentAnimal : animals) {
            // 这里体现了方法的多态性（重写 + 动态绑定）
            // 编译器只知道要调用 Animal 的 makeSound() 方法，
            // 但在运行时，会根据 currentAnimal 的实际类型来决定调用哪个版本。
            currentAnimal.makeSound();
        }
    }
}
```

### 运行结果

```text
小狗汪汪叫
小猫喵喵叫
小鸟啾啾叫
```

### 应用分析

这个 `Zoo` 示例完美地展示了多态的强大之处：

1.  **统一处理不同对象**：我们创建了一个 `Animal` 类型的数组 `animals`，但它里面可以存放 `Dog`、`Cat`、`Bird` 等任何 `Animal` 的子类对象。这就是**变量的多态性**的应用。我们无需为每种动物创建一个单独的数组。

2.  **调用行为的动态决策**：在 `for` 循环中，我们对数组中的每一个元素（`currentAnimal`）调用 `makeSound()` 方法。我们不需要写 `if (currentAnimal instanceof Dog)` 这样的判断语句来区分动物的类型。JVM 会在运行时自动判断 `currentAnimal` 的真实身份，并调用相应类中**重写**的方法。这就是**方法的多态性**的应用。

3.  **极佳的可扩展性**：如果未来动物园要引进一种新的动物，比如 `Lion`，我们该怎么做？
    - 只需创建一个 `Lion` 类，让它继承 `Animal` 并重写 `makeSound()` 方法。
    - 在创建 `animals` 数组时，将 `new Lion()` 添加进去即可。
    - `for` 循环中的代码**完全不需要任何修改**！它就能自动地、正确地调用 `Lion` 类的 `makeSound()` 方法。

这种“对修改关闭，对扩展开放”的设计原则，正是多态性为我们带来的最大好处之一。

## 5.2.5 总结

方法的多态性，无论是通过编译时确定的**重载**，还是在运行时动态绑定的**重写**，都是面向对象编程的基石。它赋予了 Java 编程语言强大的灵活性和扩展能力。

其核心价值可以概括为以下几点：

- **简化代码，提高可读性**：通过重载，我们可以用一个统一的方法名来处理不同类型的数据，让代码更直观。通过重写，我们可以用一个统一的接口来调用不同子类的具体实现，隐藏了实现的复杂性。

- **增强代码的可扩展性**：如“动物园”示例所示，当需要添加新功能（新动物）时，我们只需创建新的子类并实现约定的方法，而无需修改任何现有调用方的代码。这使得系统能够轻松地适应未来的变化。

- **提高代码的可维护性**：多态使得代码逻辑更加集中。每个子类的行为都封装在自己的内部，修改一个子类的行为不会影响到其他子类或父类，降低了维护成本。

- **实现框架与扩展的分离**：许多软件框架（如 Spring）都广泛使用多态性。框架定义好一套标准的接口（父类或接口），而开发者则通过编写具体的实现类（子类）来扩展框架的功能。多态性是连接框架和自定义扩展之间的桥梁。

总之，深入理解并熟练运用方法的多态性，是从“能写代码”到“写好代码”的关键一步。它能帮助你构建出更加健壮、灵活和易于维护的软件系统。
